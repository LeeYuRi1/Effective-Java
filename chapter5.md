# 5장 제네릭

제네릭을 지원하기 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야 했다. 
제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에 알려주게 된다. 
컴파일러는 알아서 형변환 코드를 추가하고, 엉뚱한 타입의 객체를 차단하여 안전하고 명확한 프로그램을 만들어준다. 



## 아이템26. 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라 한다. 그리고 **제네릭 클래스**와 **제네릭 인터페이스**를 통틀어 제네릭 타입이라 한다. 

각각의 제네릭 타입은 일련의 **매개변수화 타입**을 정의한다. 
클래스 이름이 나오고, 꺾쇠괄호 안에 실제 타입 매개변수들을 나열한다. 
Ex) List<Stirng>   string이 실제 타입 매개변수다. 



### 로 타입

제네릭 타입을 하나 정의하면 그에 딸린 **로 타입**도 함께 정의된다. 
로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. 
Ex) List<E>의 로 타입은 List다. 

로 타입은 타입 선언에서 제네릭 타입 정보가 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책이라 할 수 있다. 

로 타입을 쓰는걸 언어 차원에서 막아놓지 않았지만 절대로 쓰면 안된다. 
**로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.** 

List 같은 로 타입은 안되지만, List<Object>처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다.
List는 제네릭 타입에서 완전히 발을 뺀 것이고, List<Object>는 모든 타입을 허용한다는 것이다. 
매개변수화 타입을 사용할 때와 달리 로 타입을 사용하면 타입 안전성을 잃게 된다. 



### 비한정적 와일드카드 타입

로 타입 보다는 비한정적 와일드카드 타입을 사용하는 것이 좋다. 
제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 물음표를 사용하자. 
Ex) 제네릭 타입 Set<E> 의 비한정적 와일드카드 타입은 Set<?>다. 

 와일드카드 타입은 안전하고, 로 타입은 안전하지 않다. 
로 타입 컬렉션은 아무 원소가 넣을 수 있으니 타입 불변식을 훼손하기 쉽다. 

반면, **Collection<?> 에는 (null외에는) 어떤 원소도 넣을 수 없다.** 



### 예외

- **class 리터럴에는 로 타입을 써야 한다.** 
  자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다. 
  Ex) List.class, String[].class 는 허용, List<String>.class, List<?>.class는 허용하지 않는다. 
- **런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.** 
  로 타입과 비한정적 와일드카드 타입에서 instanceof는 똑같이 동작하지만 비한정적 와일드카드 타입의 꺾쇠괄호와 물음표는 코드를 지저분하게 만드므로, 로 타입을 쓰는 편이 깔끔하다. 





## 아이템27. 비검사 경고를 제거하라

제네릭을 사용하기 시작하면 수많은 컴파일러 경고를 보게 될 것이다. 
비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등이다. 

대부분의 비검사 경고는 쉽게 제거할 수 있다. 



- **할 수 있는 한 모든 비검사 경고를 제거하라.**
  제거하기 훨씬 어려운 경고도 있지만 포기하지 않고 모두 제거한다면 그 코드는 타입 안전성이 보장된다. 

- **경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 @SuppressWarnings(“unchecked”) 애너테이션을 달아 경고를 숨기자.**

- **@SuppressWarnings 애너테이션은 항상 가능한 한 좁은 범위에 적용하자.**
  @SuppressWarnings 애너테이션은 개별 지역변수 선언부터 클래스 전체까지 어떤 선언에도 달릴 수 있다. 

  - 심각한 경고를 놓칠 수 있으니 클래스 전체에 적용해서는 안된다. 

  - 한 줄이 넘는 메서드나 생성자에 달린 @SuppressWarnings 애너테이션을 발견하면 지역변수 선언 쪽으로 옮기자. 

  - 애너테이션은 선언에만 달 수 있기 때문에 return문에는 달 수 없다. 

    

- **@SuppressWarnings(“unchecked”) 애너테이션을 사용할 때면 그 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야 한다.** 
  다른 사람이 코드를 이해하는데 도움이 되며, 그 코드를 잘못 수정하여 타입 안전성을 잃는 상황을 줄여준다. 





## 아이템28. 배열보다는 리스트를 사용하라

### 배열과 제네릭 타입의 차이

- **배열은 공변이다.** 
  Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다. 

  반면, 제네릭은 불공변이다. 
  서로 다른 타입 Type1, Type2가 있을 때, List<Type1>은 List<Type2>의 하위 타입도, 상위 타입도 아니다. 
  실수를 하게 되면, 배열은 런타임에 알게 되지만 리스트는 컴파일할 때 바로 알 수 있다. 

- **배열은 실체화 된다.** 
  배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다. 
  반면, 제네릭은 타입을 컴파일타임에서만 검사하며 런타임에는 소거된다. 

  

이러한 차이로 인해 배열과 제네릭은 잘 어우러지지 못한다. 
배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다. 

제네릭 배열을 만들지 못하게 막은 이유는 타입 안전하지 않기 때문이다. 
컴파일러가 자동 생성한 형변환 코드에서 런타임에 ClassCastException이 발생할 수 있다. 



### 배열을 제네릭으로 만들 수 없어 귀찮을 때도 있다. 

- 제네릭 컬렉션에서는 자신의 원소 타입을 담은 배열을 반환하는게 보통은 불가능하다. 
- 제네릭 타입과 가변인수 메서드를 함께 쓰면 해석하기 어려운 경고 메시지를 받게 된다. 
  이 문제는 @safeVarargs 애너테이션으로 대처할 수 없다. 



### 배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우

대부분 배열인 E[] 대신 컬렉션인 List<E>를 사용하면 해결된다. 
코드가 조금 복잡해지고, 성능이 나빠질 수 있지만 타입 안전성과 상호운용성은 좋아진다. 





## 아이템29. 이왕이면 제네릭 타입으로 만들라

제네릭타입과 메서드를 사용하는 일은 일반적을 쉬운 편이지만 제네릭 타입을 새로 만드는 일은 조금 어렵다. 

일반 클래스를 제네릭 클래스로 만드는 첫 단계는 클래스 선언에 타입 매개변수를 추가하는 일이다. 타입 이름으로 보통 E를 사용한다. 

대체로 하나 이상의 오류나 경고가 뜬다. 
E와 같은 실체화 불가 타입으로는 배열을 만들 수 없다. 배열을 사용하는 코드를 제네릭으로 만들려 할 때 문제가 생길 것이다. 



### 배열을 사용한 코드를 제네릭으로 만드는 방법

- 제네릭 배열 생성을 금지하는 제약을 대놓고 우회하는 방법
- 필드의 타입을 E[]에서 Object[]로 바꾸는 방법



첫번째 방법은 가독성이 더 좋고, 코드도 더 짧다. 
배열 타입을 E[]로 선언하여 오직 E타입 인스턴스만 받음을 어필한다. 

첫번째 방식에서는 형변환을 배열 생성 시 단 한 번만 해주면 되지만, 두번째 방식에서는 배열에서 원소를 읽을 때마다 해줘야 한다. 

하지만 배열의 런타임 타입이 컴파일 타임 타입과 달라 힙 오염을 일으킨다. 





## 아이템30. 이왕이면 제네릭 메서드로 만들라

클래스와 마찬가지로, 메서드로 제네릭으로 만들 수 있다. 
매개변수화 타입을 받는 정적 유틸리티 메서드는 보통 제네릭이다.
제네릭 메서드는 경고 없이 컴파일 되며, 타입 안전하고, 쓰기 쉽다. 



### 싱글턴 팩터리

때때로 불변 객체를 여러 타입으로 활용할 수 있게 만들어야 할 때가 있다. 

제네릭은 런타임에 타입 정보가 소거되므로 하나의 객체를 어떤 타입이로든 매개변수화할 수 있다. 하지만 이렇게 하려면 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 정적 팩터리를 만들어야 한다. 
이 패턴을 제네릭 싱글턴 팩터리라고 한다. 

항등함수를 담은 클래스를 만든다고 할 때, 항등함수 객체는 상태가 없으니 요청할 때마다 새로 생성하는 것은 낭비다. 
자바의 제네릭이 실체화된다면 항등함수를 타입별로 만들어야 하지만, 소거 방식을 사용한 덕에 제네릭 싱글턴 하나면 충분하다. 



### 재귀적 타입 한정

자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정할 수 있는 것이다. 
재귀적 타입 한정은 주로 타입의 자연적 순서를 정하는 Comparable 인터페이스와 함께 쓰인다. 

훨씬 복잡해질 가능성이 있지만, 잘 일어나지 않는다. 





## 아이템31. 한정적 와일드카드를 사용해 API유연성을 높이라

매개변수화 타입은 불공변이다.
하지만 때론 불공변 방식보다 유연한 무언가가 필요하다. 

일련의 원소를 스택에 넣는 메서드를 추가해본다. 

```
public void pushAll(Iterable<E> src) { 
	for (E e : src) 
		push(e); 
} 

Stack<Number> numberStack = new Stack<>(); 
Iterable<Integer> integers = ...; 
numberStack.pushAll(integers);
```

매개변수화 타입이 불공변이기 때문에 오류메세지가 뜬다. 



### 한정적 와일드카드 타입

자바는 이런 상황에 대처할 수 있는 한정적 와일드카드 타입이라는 특별한 매개변수화 타입을 지원한다. 

```
public void pushAll(Iterable<? extends E> src) { 
	for (E e : src) 
		push(e); 
} 
```

pushAll의 입력 매개변수 타입은 ‘E의 Iterable’이 아니라 ‘E의 하위 타입의 Iterable’이어야 하며, Iterable<? Extends E> 가 이런 뜻이다. 



### PECS: producer-extends, consumer-super

유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하라.
매개변수화 타입 T가 생산자라면 <? extends T>를 사용하고, 소비자라면 <? super T>를 사용한다. pushAll의 src 매개변수는 Stack이 사용할 E인스턴스를 생산하므로 src의 적절한 타입은 Iterable<? Extends E>다. 

제대로만 사용한다면 클래스 사용자는 와일드카드 타입이 쓰였다는 사실조차 의식하지 못할 것이다. 받을 매개변수는 받고 거절할 매개변수는 거절하는 작업이 알아서 이뤄진다. 
**클래스 사용자가 와일드카드 타입을 신경 써야 한다면 그 API에 무슨 문제가 있을 가능성이 크다.** 

직접 구현한 다른 타입을 확장한 타입을 지원하기 위해 와일드카드가 필요하다. 



### 타입 매개변수와 와일드카드

타입 매개변수와 와일드카드에는 공통되는 부분이 있어서, 메서드를 정의할 때 둘 중 어느 것을 사용해도 괜찮을 때가 많다. 

**메서드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하라.** 
이때, 비한정적 타입 매개변수라면 비한정적 와일드카드로 바꾸고, 한정적 타입 매개변수라면 한정적 와일드카드로 바꾸면 된다. 





## 아이템32. 제네릭과 가변인수를 함께 쓸 때는 신중해라

가변인수 메서드와 제네릭은 자바5 때 추가 되었으나, 서로 잘 어우러지지 않는다. 
가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 만들어진다. 
이 배열을 클라이언트에 노출하는 문제가 생긴 결과, varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생한다. 

거의 모든 제네릭과 매개변수화 타입은 실체화되지 않는다. 
메서드를 선언할 때 실체화 불가 타입으로 varargs 매개변수를 선언하면 컴파일러가 경고를 보낸다. 가변인수 메서드를 호출할 때도 varargs 매개변수가 실체화 불가 타입으로 추론되면 경고를 낸다. 

 매개변수화 타입의 변수가 타입이 다른 객체를 참조하는 상황에서는 컴파일러가 자동 생성한 형변환이 실패할 수 있으니, 제네릭 타입 시스템이 약속한 타입 안전성의 근간이 흔들린다. 

**제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다.** 



### @SafeVarargs

자바 7에서는 @SafeVarargs 애너테이션이 추가되어 제네릭 가변인수 메서드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있게 되었다. 
**@SafeVarargs 애너테이션은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치다.** 

제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다. 
단, 예외가 두가지 있다. 

1. @SafeVarargs로 제대로 애노테이트된 또 다른 varargs 메서드에 넘기는 것은 안전하다.
2. 그저 이 배열 내용의 일부 함수를 호출만 하는(varargs를 받지 않는) 일반 메서드에 넘기는 것도 안전하다.



@SafeVarargs 애너테이션을 사용해야 할 때를 정하는 규칙은 간단하다. 
**제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 모든 메서드에 @SafeVarargs를 달라.**

두 조건을 모두 만족하는 제네릭 varargs 메서드는 안전하다. 

- varargs 매개변수 배열에 아무것도 저장하지 않는다. 
- 그 배열(혹은 복제본)을 신뢰할 수 없는 코드에 노출하지 않는다. 

@SafeVarargs 애너테이션은 재정의할 수 없는 메서드에만 달아야 한다



**@SafeVarargs 애너테이션이 유일한 정답은 아니다.** 
Varargs 매개변수를 List 매개변수로 바꿀 수도 있다. 
정적 팩터리 메서드인 List.of에도 @SafeVarargs 애너테이션이 달려 있기 때문에 사용할 수 있다. 

**장점**
컴파일러가 이 메서드의 타입 안전성을 검증할 수 있다. 
@SafeVarargs 애너테이션을 직접 달지 않아도 되며, 실수로 안전하다고 판단할 걱정도 없다. 

**단점**
클라이언트 코드가 살짝 지저분해지고 속도가 조금 느려질 수 있다. 





## 아이템33. 타입 안전 이종 컨테이너를 고려하라 

제네릭은 컬렉션과 단일원소 컨테이너에도 흔히 쓰이며, 매개변수화되는 대상은 컨테이너 자신이다. 따라서 하나의 컨테이너에서 매개변수화할 수 있는 타입의 수가 제한된다. 

하지만 더 유연한 수단이 필요할 때도 있다. 
컨테이너 대신 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하면 된다. 이렇게 하면 제네릭 타입 시스템이 값의 타입이 키와 같음을 보장해줄 것이다. 

이러한 설계 방식을 타입 안전 이종 컨테이너 패턴이라 한다. 



타입별로 즐겨 찾는 인스턴스를 저장하고 검색할 수 있는 Favorites 클래스를 생각해보자. 
각 타입의 Class 객체를 매개변수화한 키 역할로 사용하면 되는데, class의 클래스가 제네릭이기 때문에 동작한다. 
Class의 리터럴 타입은 Class가 아닌 Class<T>다. 
컴파일타임 타입 정보와 런타임 타입 정보를 알아내기 위해 메서드들이 주고받는 class 리터럴을 타입 토큰이라 한다. 

### 제약

1. 악의적인 클라이언트가 Class 객체를 (제네릭이 아닌) 로 타입으로 넘기면 Favorites 인스턴스의 타입 안전성이 쉽게 깨진다. 
2. 실체화 불가 타입에는 사용할 수 없다. 
   즐겨 찾는 String이나 String[]은 저장할 수 있어도 즐겨찾는 List<String>은 저장할 수 없다.
   이 제약에 대한 완벽한 우회는 없다. 



Favorites가 사용하는 타입 토큰은 비한정적이다. 
때로는 메서드들이 허용하는 타입을 제한하고 싶을 수 있는데, 한정적 타입 토큰을 활용하면 가능하다. 
한정적 타입 토큰이란 단순히 한정적 타입 매개변수나 한정적 와일드카드를 사용하여 표현 가능한 타입을 제한하는 타입 토큰이다. 
애너테이션 API는 한정적 타입 토큰을 적극적으로 사용한다. 