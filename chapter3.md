# 3장. 모든 객체의 공통 메서드

Object는 객체를 만들 수 있는 구체 클래스지만 기본적으로는 상속해서 사용하도록 설계되었다. <br>
Object를 상속하는 클래스는 메서드들을 일반 규약에 맞게 재정의해야 한다. <br>
3장에서는 final이 아닌 Object 메서드들을 언제 어떻게 정의해야 하는지를 다룬다.<br><br>



## 아이템10. equals는 일반 규약을 지켜 재정의하라

equals 메서드는 재정의하기 쉬워보이지만 자칫하면 끔찍한 결과를 초래한다. <br>
가장 쉬운 해결방법은 재정의를 하지 않는 것이다.<br>

### 재정의 하지 않아도 되는 상황

- **각 인스턴스가 본질적으로 고유하다.** <br>
  값을 표현하는게 아니라 동작하는 개체를 표현하는 클래스가 여기 해당한다.  <br>
  ex) Thread<br>

- **인스턴스의 ‘논리적 동치성’을 검사할 일이 없다.**<br>
  Java.util.regex.Pattern은 equals를 재정의해서 두Pattern의 인스턴스가 같은 정규표현식을 나타내는지 검사하는 방법도 있다. <br>
  하지만 이 방식을 원하지 않거나 필요하지 않다고 판단하면 Object의 기본 equals만으로 해결된다.<br>

- **상위클래스에서 재정의한 equals가 하위클래스에도 딱 들어맞는다.** <br>
  대부분의 Set구현체는 AbstractSet이 구현한 equals를 상속받아 쓰고, List 구현체들은 AbstractList로부터, Map구현체들은 AbstractMap으로부터 상속받아 그대로 쓴다.<br>

- **클래스가 private이거나 package-private이면 equals 메서드를 호출할 일이 없다.** <br>
  Equals가 실수로라도 호출되는 걸 막고 싶다면 이렇게 구현한다. <br>

  ```
  @Override public Boolean equals(Object o) {
  
             Throw new AssertionError(); //호출 금지
  
  }
  ```

   

### 정의해야 하는 상황<br>

- **객체 식별성이 아니라 논리적 동치성을 확인해야 하는데, 상위클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때**<br>
  주로 값 클래스들이 여기 해당한다.<br>
  객체가 같은지가 아니라 값이 같은지를 알고 싶어할 때, equals가 논리적 동치성을 확인하도록 재정의해둔다. <br>

  **값 클래스라고 해도, 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제클래스라면 equals를 재정의하지 않아도 된다.** <br>

  Ex) Enum – 같은 인스턴스가 2개 이상 만들어지지 않기 때문에 논리적 동치성과 객체 식별성이 같은 의미가 된다. <br>

  

### Equals 메서드를 재정의할 때 따라야 하는 일반 규약 <br>

equals 메서드는 동치관계를 구현하며, 다음을 만족한다. <br>

- **반사성**<br>
  객체는 자기 자신과 같아야 한다. <br>

- 대칭성<br>
  두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.<br>

- 추이성<br>
  첫번째 객체와 두번째 객체가 같고, 두번째 객체와 세번째 객체가 같다면, 첫번째 객체와 세번째 객체도 같아야 한다. <br>

  구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다. 하지만 우회방법으로 상속 대신 컴포지션을 사용하는 방법이 있다. <br>

- 일관성 <br>
  두 객체가 같다면 앞으로도 영원히 같아야 한다. <br>
  클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안된다.<br>

- null-아님<br>
  모든 객체가 null과 같지 않아야 한다. <br>
  명시적 null 검사는 필요하지 않다.<br>
  Instanceof 연산자로 입력 매개변수가 올바른 타입인지 검사할 때 null검사를 포함한다. <br>



### 양질의 equals 메서드 단계별 구현 방법<br>

1. **==연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.** <br>
2. **instanceof 연산자로 입력이 올바른 타입인지 확인한다.**<br>
3. **입력을 올바른 타입으로 형변환한다.** <br>
4. **입력 객체와 자기 자신의 대응되는 핵심필드들이 모두 일치하는지 하나씩 검사한다.** <br>



### 주의사항<br>

- **equals를 재정의할 때는 hashCode도 반드시 재정의하자**<br>
- **너무 복잡하게 해결하려 들지 말자**<br>
- **Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자**<br>
  Equals를 작성하고 테스트하는 일을 대신해줄 오픈소스로 구글이 만든 AutoValue 프레임워크가 있다.<br>





## 아이템11. Equals를 재정의하려거든 hashCode도 재정의하라.<br>

Equals를 재정의한 클래스 모두에서 hashCode도 재정의 해야한다. <br>
그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap, HashSet 같은 컬렉션의 원소로 사용할 때 문제를 일으킨다. <br>



다음은 Object 명세에서 발췌한 규약이다.<br>

- **equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다.** <br>
  단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다. <br>
- **equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑 같은 값을 반환해야 한다.**<br>
- **equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다.** <br>
  단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다. <br>



### 좋은 hashCode 작성 요령<br>

1. int변수 result를 선언한 후 값 c로 초기화한다. <br>
   이때 c는 해당 객체의 첫번째 핵심 필드를 단계 2.a 방식으로 계산한 해시코드<br>

2. 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행한다.<br>

   ​		a. 해당 필드의 해시코드 c를 계산한다.<br> 

   ​			●  기본 타입 필드라면, Type.hashCode(f)를 수행한다. 

   ​                        	(Type은 해당 기본 타입의 박싱 클래스)

   ​			●  참조 타입 필드면서 이 클래스의 equals 메서드가 이 필드의 equals를 재귀적				으로 호출해 비교한다면, 이 필드의 hashCode를 재귀적으로 호출한다. 
   ​				계산이 더 복잡해질 것 같으면, 이 필드의 표준형을 만들어 그 표준형의 					hashCode를 호출한다. 필드의 값이 null이면 0을 사용한다. 

   ​			●  필드가 배열이라면, 핵심 원소 각각을 별도 필드처럼 다룬다. 이상의 규칙을 재귀적으로
   ​				적용해 각 핵심 원소의 해시 코드를 계산한 다음, 단계 2.b 방식으로 갱신한다. 	
   ​				배열에 핵심 원소가 하나도 없다면 단순히 상수를 사용한다.
   ​				모든 원소가 핵심원소라면 Arrays.hashCode를 사용한다.

   ​		b. 단계 2.a에서 계산한 해시코드 c로 result를 갱신한다. 코드로는 다음과 같다.

   ​              	result = 31 * result + c;

3. result를 반환한다. <br>

파생 필드는 해시코드 계산에서 제외해도 된다. <br>
또한 equals 비교에 사용되지 않는 필드는 반드시 제외해야 한다. <br>
그렇지 않으면 hashCode 규약 두번째를 어기게 될 위험이 있다.<br>

단계 2.b의 31 * result는 필드를 곱하는 순서에 따라 result 값이 달라지게 한다. <br>
그 결과 클래스에 비슷한 필드가 여러 개일 때 해시 효과를 크게 높여준다. <br>
곱할 숫자를 31로 하면, 곱셈을 시프트 연산과 뺄셈으로 대체해 최적화할 수 있다. <br>



**성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안된다.** <br>

**hashCode가 반환하는 값의 생성 규칙을 API사용자에게 자세히 공표하지 말자.** <br>
**그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후에 계산 방식을 바꿀 수도 있다.** <br>





## 아이템12. toString을 항상 재정의하라<br>

toString의 일반 규약에 따르면 간결하면서 사람이 읽기 쉬운 형태의 유익한 정보를 반환해야 한다. <br>또한 모든 하위 클래스에서 이 메서드를 재정의하라고 한다. <br>

toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다. <br>



### 좋은 toString<br>

- **toString은 객체가 가진 주요 정보 모두를 반환하는게 좋다.**<br>
  이상적으로는 스스로를 완벽히 설명하는 문자열이어야 한다. <br>
- **포맷을 명시하든 아니든 의도는 명확히 밝혀야 한다.**<br>
- **포맷 명시 여부와 상관없이 toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자.**<br>
  그렇지 않으면 toString의 반환값을 파싱할 수밖에 없다.<br>



### toString을 제공할 필요 없는 경우<br>

- 정적 유틸리티 클래스<br>

- 대부분의 열거 타입<br>

  

하지만 하위 클래스들이 공유해야 할 문자열 표현이 있는 추상 클래스라면 toString을 재정의해줘야 한다. <br>
대다수의 컬렉션 구현체는 추상 컬렉션 클래스들의 toString 메서드를 상속해 쓴다. <br>





## 아이템13. clone 재정의는 주의해서 진행하라<br>

Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스이다.<br>
하지만 clone 메서드가 선언된 곳이 Cloneable이 아닌 Object이고, protected이므로 Cloneable을 구현하는 것만으로는 외부 객체에서 clone메서드를 호출할 수 없다. <br>

메서드 하나 없는 Cloneable 인터페이스는 clone의 동작 방식을 결정한다. <br>
Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면 CloneNotSupportedException을 던진다. <br>



### clone 메서드의 일반 규약은 허술하다. <br>

강제성이 없다는 점만 빼면 생성자 연쇄와 비슷한 메커니즘이다. <br>
즉, clone메서드가 super.clone이 아닌, 생성자를 호출해 얻은 인스턴스를 반환해도 컴파일러를 불평하지 않을 것이다. <br>



**clone 메서드는 사실상 생성자와 같은 효과를 낸다.** <br>

즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다. <br>
스택 내부 정보를 복사하는 가장 쉬운 방법은 clone을 재귀적으로 호출하는 것이다. <br>
하지만 필드가 final일 경우 새로운 값을 할당할 수 없기 때문에 작동하지 않는다.<br>



**Cloneable 아키텍처는 ‘가변 객체를 참조하는 필드는 final로 선언하라’는 일반 용법과 충돌한다.** <br>

그래서 복제할 수 있는 클래스를 만들기 위해 일부 필드에서 final 한정자를 제거해야 할 수도 있다. <br>



**clone을 재귀적으로 호출하는 것만으로는 충분하지 않을 때도 있다.** <br>

해시테이블용 clone 메서드를 생각해볼 때, 해시테이블 내부는 버킷들의 배열이고, 각 버킷은 키-값 쌍을 담는 연결리스트의 첫번째 엔트리를 참조한다. <br>

버킷 배열의 clone을 재귀적으로 호출할 때, 복제본은 자신만의 버킷 배열을 갖지만, 이 배열은 원본과 같은 연결리스트를 참조하여 원본과 복제본 모두 예기치 않게 동작할 가능성이 있다. <br>

- 각 버킷을 구성하는 연결 리스트를 복사한다. <br>
  간단하며, 버킷이 너무 길지 않다면 잘 작동하지만, 연결리스트를 복제하는 방법으로는 좋지 않다. 리스트가 길면 스택 오버플로를 일으킬 수 있다. <br>
- 재귀 호출 대신 반복자를 써서 순회하는 방향으로 수정한다. <br>



**복잡한 가변 객체를 복제하는 마지막 방법**<br>

먼저 super.clone을 호출하여 얻은 객체의 모든 필드를 초기상태로 설정한 다음, 원본 객체의 상태를 다시 생성하는 고수준 메서드들을 호출한다. <br>
고수준 API를 활용해 복제하면 간단하고 우아한 코드를 얻게 되지만, 저수준에서 바로 처리할 때보다는 느리다. <br>



### 참고사항<br>

- Object의 clone메서드는 CloneNotSupportedException을 던진다고 선언했지만 재정의한 메서드는 그렇지 않다. Public인 clone 메서드에서는 throws절을 없애야 한다. <br>
- 상속해서 쓰기 위한 클래스 설계 방식에서 상속용 클래스는 Cloneable을 구현해서는 안된다.<br>
  Object의 방식을 모방할 수도 있다. <br>
- Cloneable을 구현한 스레드 안전 클래스를 작성할 때는 clone메서드도 적절히 동기화해줘야 한다. <br>
  즉, Cloneable을 구현하는 모든 클래스는 clone을 재정의해야 한다. <br>



### 복사 생성자와 복사 팩터리<br>

복사 생성자와 복사 팩터리라는 더 나은 객체 복사 방식을 제공할 수 있다. <br>
복사 생성자란 단순히 자신과 같은 클래스의 인스턴스를 인수로 받는 생성자를 말한다. <br>
언어 모순적이고 객체 생성 매커니즘을 사용하지 않으며, 엉성하게 문서화된 규약에 기대지 않고, final 필드 용법과도 충돌하지 않으며, 불필요한 검사 예외를 던지지 않고, 형변환도 필요치 않다. <br>





## 아이템14. Comparable을 구현할지 고려하라<br>

compareTo는 Comparable 인터페이스의 유일한 메서드이다. <br>
compareTo는 단순 동치성 비교에 더해 순서까지 비교할 수 있으며, 제네릭하다. <br>
Comparable을 구현했다는 것은 그 클래스의 인스턴스들에는 자연적인 순서가 있음을 뜻한다. <br>
검색, 극단값 계산, 자동 정렬되는 컬렉션 관리도 쉽게 할 수 있다. <br>



### compareTo메서드의 일반 규약<br>

compareTo메서드의 일반 규약은equals의 규약과 비슷하다. <br>

- **두번째 참조의 순서를 바꿔 비교해도 예상한 결과가 나와야 한다.** <br>
- **첫번째가 두번째보다 크고 두번째가 세번째보다 크면, 첫번째는 세번째보다 커야 한다.**<br>
- **크기가 같은 객체들끼리는 어떤 객체와 비교하더라도 항상 같아야 한다. (권장)**<br>

세 규약은 compareTo 메서드로 수행하는 동치성 검사도 equals 규약과 똑같이 반사성, 대칭성, 추이성을 충족해야 함을 뜻한다. <br>
그래서 주의사항도 같다. 기존 클래스를 확장한 구체클래스에서 새로운 값 컴포넌트를 추가했다면 compareTo규약을 지킬 방법이 없다. <br>



### compareTo 메서드 작성 요령<br>

equals와 비슷하지만 몇 가지 차이점만 주의하면 된다. <br>

- **입력 인수의 타입을 확인하거나 형변환할 필요가 없다.** <br>
  Comparable은 타입을 인수로 받는 제네릭 인터페이스이므로 compareTo 메서드의 인수 타입은 컴파일타임에 정해진다. <br>
- **compareTo 메서드는 각 필드가 동치인지를 비교하는게 아니라 그 순서를 비교한다.** <br>
  객체 참조 필드를 비교하려면 compareTo메서드를 재귀적으로 호출한다. <br>
  Comparable을 구현하지 않은 필드나 표준이 아닌 순서로 비교해야 한다면 비교자를 대신 사용한다. <br>
- **관계 연산자 <와 >는 거추장스럽고 오류를 유발하기 때문에, 정적 메서드인 compare를 이용하는 것이 좋다.** <br>
- **클래스에 핵심 필드가 여러 개라면 가장 핵심적인 피드부터 비교해 나가자.**<br>
  그 결과를 곧장 반환하자.<br>



### Comparator<br>

자바8에서는 Comparator 인터페이스가 비교자 생성 메서드와 함께 비교자를 생성할 수 있게 되었다. <br>
방식이 간결하지만, 약간의 성능 저하가 뒤따른다. <br>

- **Comparator는 수많은 보조 생성 메서드들로 중무장하고 있다.** <br>

- **객체 참조용 비교자 생성 메서드도 준비되어 있다.**<br>

   



출처 - Effective Java 3/E
