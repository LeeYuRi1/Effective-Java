# 4장 클래스와 인터페이스

 <br>

## 아이템15. 클래스와 멤버의 접근 권한을 최소화하라

잘 설계된 컴포넌트와 아닌 것의 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 잘 숨겼는지다. <br>
잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨기며, API를 깔끔히 분리한다. <br>
이 개념을 정보 은닉, 캡슐화라고 한다. <br>

### 정보 은닉의 장점

- **시스템 개발 속도를 높인다.**

- **시스템 관리 비용을 낮춘다.**

- **정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다.**

- **소프트웨어 재사용성을 높인다.**

- **큰 시스템을 제작하는 난이도를 낮춰준다.** 

  

자바는 정보 은닉을 위한 다양한 장치를 제공하는데, 그중 접근 제어 매커니즘은 클래스, 인터페이스, 멤버의 접근성을 명시한다. <br>
각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자로 정해지는데, 접근 제한자를 제대로 활용하는 것이 정보 은닉의 핵심이다. <br><br>



### **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.** 

올바로 동작하는 한 가장 낮은 접근 수준을 부여한다. 

- 톱레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 package-private와 public이 있다.<br>
  public으로 선언하면 공개 API가 되며, package-private로 선언하면 해당 패키지 안에서만 이용 가능하다. <br>
- 패키지 외부에서 쓸 이유가 없다면 package-private으로 선언해야 내부구현이 되어 언제든 수정할 수 있다. <br>
- 한 클래스에서만 사용하는 package-private클래스의 안에 package static으로 중첩시키면, 바깥 클래스 하나에서만 접근할 수 있다.<br>
- public일 필요 없는 클래스의 접근 수준을 package-private로 좁혀야 한다.<br>
- 클래스의 공개 API를 세심히 설계한 후, 그 외 모든 멤버는 private으로 만든다. <br>
  그런 다음 같은 패키지의 다른 클래스가 접근해야 하는 멤버만 package-private으로 풀어준다. <br>
- protected 멤버의 수는 적을수록 좋다. <br>
- 상위 클래스의 메서드를 재정의할 때는 접근 수준을 상위클래스에서보다 좁게 설정할 수 없다.<br>
- 테스트만을 위해 클래스, 인터페이스, 멤버를 공개 API로 만들어서는 안된다.<br>
  테스트코드를 테스트 대상과 같은 패키지에 두면 package-private요소에 접근할 수 있기 때문에 그럴 필요
  없다.<br>
- puclic 클래스의 인스턴스필드는 되도록 public이 아니어야 한다.<br>
  그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다. <br>
  필드가 수정될 때 다른 작업을 할 수 없게 되므로 public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다. <br>
  예외로, 꼭 필요한 구성요소로써의 상수라면 public static final필드로 공개해도 좋다. <br>
- 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.<br>
  클라이언트에서 그 배열의 내용을 수정할 수 있게 되기 때문이다.<br><br>



### 모듈 시스템

자바9에서 모듈 시스템이 도입되면서 두가지 암묵적 접근 수준이 추가되었다. <br>
모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서, 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있다. <br>

- 암묵적 접근 수준들은 각각 public 수준과 protected 수준과 같으나, 모듈 내부로 한정되는 변종이다.<br>
  패키지들 사이에서 클래스들을 재배치하면 대부분 해결된다.<br>
-  기존 접근 수준과 달리 주의해서 사용해야 한다. <br>
  모듈의 JAR 파일을 자신의 모듈 경로가 아닌 애플리케이션의 클래스패스에 두면 모듈의 공개 여부와 상관없이 public 클래스가 선언한 public, protected 멤버를 모듈 밖에서도 접근할 수 있게 된다. <br><br><br>





## 아이템16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

인스턴스 필드들을 모아놓는 일 외에 아무 목적 없는 퇴보한 클래스를 작성할 때가 있다. <br>
API를 수정하지 않고는 내부 표현을 바꿀 수 없고, 불변식을 보장할 수 없으며, 외부에서 필드에 접근할 때 부수 작업을 수행할 수도 없다. <br>

**이럴 때, 필드들을 모두 private으로 바꾸고 public 접근자(getter)를 추가한다.** <br>

Public 클래스가 필드를 공개하면 이를 사용하는 클라이언트가 생겨날 것이므로 내부 표현 방식을 마음대로 바꿀 수 없게 된다. <br>
하지만 **package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다.** <br>
클래스 선언, 클라이언트 코드가 더 깔끔하고 패키지 바깥 코드에 손대지 않고도 데이터 표현 방식을 바꿀 수 있다. <br><br><br>





## 아이템17. 변경 가능성을 최소화하라

불변 클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스다. <br>
자바 플랫폼 라이브러리의 불변 클래스는 String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal이 있다.<br>
불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 안전하다.<br><br>

### 클래스를 불변으로 만들기 위한 규칙

- **객체의 상태를 변경하는 메서드를 제공하지 않는다.** 
- **클래스를 확장할 수 없도록 한다.** 
- **모든 필드를 final로 선언한다.** 
- **모든 필드를 private으로 선언한다.** 
- **자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.** 

 <br>

### 불변 클래스의 장점

- **불변 객체는 단순하다.**<br>
  불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다. 프로그래머가 다른 노력을 들이지 않아도 된다. <br>
- **불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다.** <br>
  여러 스레드가 동시에 사용해도 훼손되지 않는다. <br>
  어떤 스레드라도 다른 스레드에 영향을 줄 수 없으니 불변 객체는 안심하고 공유할 수 있다. <br>
  따라서, 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용하기를 권한다. <br>
  불변 객체를 자유롭게 공유할 수 있기 때문에 방어적 복사는 필요 없다. 그러니 clone메서드나 복사 생성자를 제공하지 않는게 좋다. <br>
- **불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.** <br>
- **객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.** <br>
  구조가 복잡하더라도 불변식을 유지하기 훨씬 수월하기 때문이다. <br>
- **불변 객체는 그 자체로 실패 원자성을 제공한다.** <br>
  상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다. <br>
  실패 원자성이란 메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태여야 한다는 성질이다. <br><br>



### 불변 클래스의 단점

- **값이 다르면 반드시 독립된 객체로 만들어야 한다.** <br>
  값의 가짓수가 많다면 만드는데 큰 비용이 든다. <br><br>
  
### 불변 클래스를 만드는 다른 방법<br>
- **모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공한다.** <br>
  정적 팩터리 방식은 다수의 구현 클래스를 활용한 유연성을 제공하고, 다음 릴리스에서 객체 캐싱 기능을 추가해 성능을 끌어올릴 수도 있다. <br><br>



### 정리

- **getter가 있다고 해서 무조건 setter를 만들지 말자**<br>
- **클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.** <br>
- **불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.** <br> 
  객체를 예측하기 쉬워지고, 오류가 생길 가능성이 줄어든다. <br>
  다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.<br>
- **생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.** <br> 
  확실한 이유가 없다면 생성자와 정적 팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안된다. <br>
  객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안된다. <br>
  복잡성만 커지고 성능 이점은 거의 없다. <br><br><br>





## 아이템18. 상속보다는 컴포지션을 사용하라

상속은 재사용하는 강력한 수단이지만, 잘못하면 오류를 내기 쉬운 소프트웨어를 만들게 된다.<br>
다른 패키지의 구체 클래스를 상속하는 일은 위험하다. <br>

**메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.** <br>
상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. <br><br>

### 컴포지션

기존 클래스가 새로운 클래스의 구성요소로 쓰인다. <br>
기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 한다. 새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서도를 호출해 그 결과를 반환한다. <br>
이 방식을 전달이라 하며, 새 클래스의 메서드들을 전달 메서드라 부른다. <br>

그 결과 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향 받지 않는다.<br>

상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 쓰여야 한다.<br>
컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 것이다.<br>
API가 내부 구현에 묶이고 그 클래스의 성능도 영원히 제한된다. <br>
더 심각한 문제는 클라이언트가 노출된 내부에 직접 접근할 수 있다는 점이다.<br>
또한 사용자를 혼란스럽게 할 수 있다. <br><br><br>





## 아이템19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

아이템18에서는 상속을 염두에 두지 않고 설계했고 상속할 때의 주의점도 문서화 해놓지 않은 외부 클래스를 상속할 때의 위험을 경고했다. <br>
상속을 고려한 설계와 문서화는 메서드를 재정의할 때 어떤 일이 일어나는지 정리하여 문서로 남기는 것이다. <br>
**상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기 사용) 문서로 남겨야 한다.** <br>

- 클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수 있기 때문이다. <br>
- 어떤 순서로 호출하는지, 각각의 결과가 어떤 영향을 주는지도 담아야 한다. <br>
- 상속이 캡슐화를 해치기 때문에 일어나는 안타까운 현실이다. <br>
- 클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야만 한다. <br><br>



내부 메커니즘을 문서로 남기는 방법이 전부는 아니다. <br>
효율적인 하위클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.  드물게 protected 필드로 공개해야 할 수도 있다. <br>

- **어떤 메서드를 protected로 해야 할지는 잘 예측해본 다음, 실제 하위 클래스를 만들어 시험해보는 것이 최선이다.**<br>
  그 수는 가능한 한 적어야 한다. <br>
- **상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.** <br>
- **상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.** <br>
  선택한 결정에 영원히 책임져야하기 때문이다. <br>
- **상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.** <br>
  어기면 프로그램이 오동작할 것이다. <br><br>



### Cloneable과 Serializable

Cloneable과 Serializable 인터페이스는 상속용 설계의 어려움을 더해준다. <br>
그 클래스를 확장하려는 프로그래머에게 엄청난 부담을 지우기 때문이다. <br>
Clone과 readObject 메서드는 생성자와 비슷한 효과를 낸다. <br>
따라서 상속용 클래스에서 Cloneable과 Serializable을 구현할 때 따르는 제약도 생성자와 비슷하다. <br>

- **Clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.** <br>
  어느쪽이든 프로그램 오작동으로 이어지고, clone이 잘못되면 원본 객체에도 피해를 줄 수 있다. <br>
- **Serializabledmf 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 private이 아닌 protected로 선언해야 한다.** <br>
  Private로 선언하면 하위클래스에서 무시되기 때문이다. <br><br>



### 일반적인 구체 클래스

Final도 아니고 상속용으로 설계되거나 문서화되지도 않았디만 그대로 두면 위험하다. <br>
클래스에 변화가 생길 때마다 하위 클래스를 오작동하게 만들 수 있기 때문이다. <br>

**가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다**<br>

- 구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기 불편해진다. <br>
  상속을 꼭 허용해야겠다면 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남기면 된다. <br>
  재정의 가능 메서드를 호출하는 자기 사용 코드를 완벽히 제거하는 것이다. <br>

- 클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 기계적인 방법<br>
  먼저 각각의 재정의 가능 메서드는 자신의 본문 코드를 private ‘도우미 메서드’로 옮기고 이 도우미 메서드를 호출하도록 수정한다. <br>
  재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정하면 된다. <br><br><br>





## 아이템20. 추상 클래스보다는 인터페이스를 우선하라

자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상클래스가 있다. 
자바8부터 인터페이스도 디폴트 메서드를 제공할 수 있게 되어 두 매커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있다. 
가장 큰 차이는 추상클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위클래스가 되어야 한다. 인터페이스는 같은 타입으로 취급된다. 

- **기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있다.** 
  인터페이스가 요구하는 메서드를 추가하고, 클래스 선언에 implements 구문만 추가하면 된다.
  하지만 클래스 계층 구조에 혼란을 일으킨다. 새로 추가된 추상 클래스의 모든 자손이 이를 상속하게 된다. 
- **인터페이스는 믹스인 정의에 안성맞춤이다.** 
  믹스인이란 클래스가 구현할 수 있는 타입으로, 클래스에 원래의 주된 타입 외에 특정 선택적 행위를 제공한다고 선언하는 효과를 준다. 
  추상클래스는 믹스인을 정의할 수 없다. 기존 클래스에 덧씌울 수 없기 때문이다. 
- **인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.** 
  같은 구조를 클래스로 만들려면 고도비만 계층구조가 만들어질 것이다. 
  인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 되지만, 타입을 추상 클래스로 정의하면 그 타입에 기능을 추가하는 방법은 상속뿐이다.
  상속해서 만든 클래스는 활용도가 떨어지고 깨지기 더 쉽다. 
- **인터페이스의 메서드 구현을 디폴트 메서드로 제공하면 프로그래머들의 일감을 덜어줄 수 있다.** 
  디폴트 메서드를 제공할 때는 상속하려는 사람들 위한 설명을 @isplSpec 자바독 태그를 붙여 문서화해야 한다. 



### 추상 골격 구현

인터페이스와 추상 골격 구현 클래스를 함께 제공하면 인터페이스와 추상 클래스의 장점을 모두 취할 수 있다. 

- 인터페이스로는 타입을 정의하고, 필요하면 디폴트 메서드도 함께 제공한다. 골격 구현 클래스는 나머지 메서드들까지 구현한다. 
- 인터페이스 이름이 Interface라면 골격 구현 클래스의 이름은 AbstractInterface로 짓는다. 
- 추상 클래스처럼 구현을 도와주는 동시에, 추상 클래스로 타입을 정의할 때 따라오는 심각한 제약에서는 자유롭다. 
- 우회적으로 이용할 수도 있다. 
  인터페이스를 구현한 클래스에서 해당 골격 구현을 확장한 private 내부 클래스를 정의하고, 각 메서드 호출을 내부 클래스의 인스턴스에 전달하는 것이다. 
  이 방식을 시뮬레이트한 다중 상속이라고 하며, 다중 상속의 많은 장점을 제공하는 동시에 단점은 피하게 해준다.  
- 골격 구현 작성은 상대적으로 쉽다. 
- 골격 구현은 기본적으로 상속해서 사용하는 걸 가정하므로 설계 및 문서화 지침을 따라야 한다. 

**단순 구현은 골격 구현의 작은 변종이다.** 
골격 구현과 같이 상속을 위해 인터페이스를 구현한 것이지만, 추상클래스가 아니다. 



## 아이템21. 인터페이스는 구현하는 쪽을 생각해 설계하라

자바8 전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 메서드를 추가할 수 없었다. 
자바8에서는 디폴트 메서드를 소개했지만 위험이 사라진 것은 아니다. 

### 디폴트 메서드

디폴트 메서드를 선언하면, 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다. 
하지만 모든 기존 구현체들과 매끄럽게 연동되리라는 보장은 없다. 

자바8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었는데, 람다를 활용하기 위해서다. 

### **장점**

코드 품질이 높고 범용적이라 대부분 상황에서 잘 작동한다. 

### **단점**

**생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기는 어렵다.** 
디폴트 메서드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다.



기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다. 반면, 새로운 인터페이스를 만드는 경우라면 표준적인 메서드 구현을 제공하는데 유용하고, 인터페이스를 더 쉽게 구현해 활용할 수 있게 해준다. 

디폴트 메서드는 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도가 아니다. 

**디폴트 메서드가 있더라도 인터페이스를 설계할 때는 주의를 기울여야 한다.** 



새로운 인터페이스라면 릴리스 전에 반드시 테스트를 거쳐야 한다. 최소한 세가지는 구현해봐야 하고 클라이언트도 여러 개 만들어봐야 한다. 
**인터페이스를 릴리스한 후라도 결함을 수정하는게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안된다.** 





## 아이템22. 인터페이스는 타입을 정의하는 용도로만 사용하라

인터페이스는 자신이 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다. 
인터페이스는 오직 이 용도로만 사용해야 한다.  

아닌 예로 상수 인터페이스가 있다. 
상수 인터페이스란 메서드 없이, 상수를 뜻하는 static final 필드만 있는 인터페이스를 말한다. 
클래스에서 정규화된 이름을 쓰는걸 피하고자 구현한다. 

**상수 인터페이스 안티 패턴은 인터페이스를 잘못 사용한 예다.** 
상수 인터페이스를 구현하는 것은 내부 구현을 클래스의 API로 노출하는 행위다. 
사용자에게 혼란을 주며, 심하게는 클라이언트 코드가 내부 구현에 해당하는 상수들에 종속되게 한다.

 

**상수를 공개할 목적**이라면 더 합당한 선택지가 몇가지 있다. 

- 특정 클래스나 인터페이스와 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 추가해야 한다. 

- 열거 타입으로 나타내기 적합한 상수라면 열거 타입으로 만들어 공개하면 된다. 

- 그것도 아니라면 인스턴스화할 수 없는 유틸리티 클래스에 담아 공개한다. 

 



## 아이템23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라

### 태그 달린 클래스

태그 달린 클래스는 단점이 많다.

- 쓸데없는 코드가 많다. 
- 가독성이 나쁘다. 
- 메모리를 많이 사용한다. 
- 필드들을 final로 선언하려면 해당 의미에 쓰이지 않는 필드들까지 생성자에서 초기화해야 한다.
- 다른 의미를 추가하려면 코드를 수정해야 한다. 
- 인스턴스의 타입만으로는 현재 나타내는 의미를 알 길이 없다. 

**태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다.** 



객체지향언어는 타입 하나로 다양한 의미의 객체를 표현하는 수단인 클래스 계층 구조를 활용하는 서브타이핑을 제공한다. 

### 클래스 계층구조

- 간결하고 명확하며, 태그 달린 클래스에서의 쓸데 없는 코드를 모두 제거한다. 
- 루트 클래스의 코드를 건드리지 않고도 다른 프로그래머들이 독립적으로 계층구조를 확장하고 함께 사용할 수 있다. 
  타입이 의미 별로 존재해서 변수의 의미를 명시, 제한할 수 있고 특정 의미만 매개변수로 받을 수 있다. 
- 유연성은 물론 컴파일타임 타입 검사 능력을 높여준다. 





## 아이템24. 멤버 클래스는 되도록 static으로 만들라

중첩 클래스란 다른 클래스 안에 정의된 클래스를 말한다.
자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그 외에 쓰임새가 있으면 톱 레벨 클래스로 만들어야 한다. 

중첩 클래스의 종류는 정적 멤버 클래스, (비정적)멤버 클래스, 익명 클래스, 지역 클래스가 있다. 
정적 멤버 클래스를 제외한 나머지는 내부 클래스에 해당한다. 



### 정적 멤버 클래스

- 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점을 빼면 일반 클래스와 똑같다. 
- 다른 정적 멤버와 똑 같은 접근 규칙을 적용 받는다. 
  private으로 선언하면 바깥 클래스에서만 접근할 수 있다.
- 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 쓰인다. 
- 정적 멤버 클래스와 비정적 멤버 클래스의 구문상 차이는 static이 붙느냐 뿐이지만, 의미상 차이는 크다. 



### 비정적 멤버 클래스 

- 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다. 
- 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 한다. 
  비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없기 때문이다. 
- 비정적 멤버 클래스의 인스턴스와 바깥 인스턴스 사이의 관계는 멤버 클래스가 인스턴스화될 때 확립되며, 더 이상 변경할 수 없다. 
- 비정적 멤버 클래스는 어댑터를 정의할 때 자주 쓰인다. 
  즉, 어던 클래스의 인스턴스를 감싸 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용한다. 
- 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자
  시간과 공간이 소비되고, 메모리 누수가 생길 수 있다. 



### 익명 클래스

- 이름이 없다. 
- 바깥 클래스의 멤버가 아니다. 
- 멤버와 달리, 쓰이는 시점에 선언과 동시에 인스턴스가 만들어지며, 코드의 어디서든 만들 수 있다. 
- 비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다. 
- 응용하는데 제약이 많은 편이다. 
- 익명 클래스는 정적 팩터리 메서드를 구현할 때 주로 쓰인다. 



### 지역 클래스

- 가장 드물게 사용된다. 
- 지역 변수를 선언할 수 있는 곳이면 어디서든 선언할 수 있고, 유효 범위도 지역 변수와 같다. 
- 멤버 클래스처럼 이름이 있고 반복해서 사용할 수 있다. 
- 익명 클래스처럼 비정적 문맥에서 사용될 때만 바깥 인스턴스를 참조할 수 있으며, 정적 멤버는 가질 수 없으며, 가독성을 위해 짧게 작성해야 한다. 





## 아이템25. 톱레벨 클래스는 한 파일에 하나만 담으라

소스 파일 하나에 톱레벨 클래스를 여러 개 선언하더라도 자바 컴파일러는 불평하지 않지만 아무런 득도 없고, 심각한 위험을 감수해야 한다. 
이렇게 하면 한 클래스를 여러 가지로 정의할 수 있고, 어느 것을 사용할지는 어느 소스 파일을 먼저 컴파일하냐에 따라 달라지기 때문이다. 



### 해결책

톱레벨 클래스들을 서로 다른 소스 파일로 분리하면 된다. 
굳이 여러 톱레벨 클래스를 한 파일에 담고 싶다면 정적 멤버 클래스를 사용하는 방법이 있다. 
