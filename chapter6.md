# 6장. 열거 타입과 애너테이션
<br>
자바에는 특수한 목적의 참조 타입이 두가지가 있다. <br>
하나는 클래스의 일종인 열거 타입이고, 다른 하나는 인터페이스의 일종인 애너테이션이다. <br>

 <br>

## 아이템34. Int 상수 대신 열거 타입을 사용하라

열거 타입은 일정 개수의 상수 값을 정의한 다음, 그 외의 값은 허용하지 않는 타입이다. <br>

<br>

### 정수 열거 패턴

열거 타입을 지원하기 전에는 정수 상수를 한 묶음에 선언해서 사용하곤 했다. <br>
정수 열거 패턴 기법에는 단점이 많다.<br>

- 타입 안전을 보장할 방법이 없으며 표현력도 좋지 않다. <br>
- 정수 열거 패턴을 사용한 프로그램은 깨지기 쉽다. <br>
- 정수 상수는 문자열로 출력하기가 다소 까다롭다. <br>
- 정수 대신 문자열 상수를 사용하는 변형 패턴도 있다. <br>
  하지만 이 문자열 열거 패턴은 더 나쁘다. <br>
  상수의 의미를 출력할 수 있지만, 문자열 상수의 이름 대신 문자열 값을 그대로 하드코딩하게 만든다. <br>

<br>

### 열거 타입

- 자바 열거 타입을 뒷받침하는 아이디어는 단순하다. <br>
  열거 타입 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개한다. 생성자를 제공하지 않으므로 사실상 final이다. 열거 타입은 인스턴스 통제되며, 싱글턴을 일반화한 형태라고 볼 수 있다. <br>
- 열거 타입은 컴파일타임 타입 안전성을 제공한다. <br>
- 열거 타입에는 각자의 이름공간이 있어서 이름이 같은 상수도 평화롭게 공존한다. <br>
- 그 외, 임의의 메서드나 필드를 추가할 수 있고 임의의 인터페이스를 구현하게 할 수도 있다. <br>
- **열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.** <br>
  모든 필드는 final이어야 한다. public으로 선언해도 되지만, private으로 두고 별도의 public 접근자 메서드를 두는게 낫다. <br>
- 열거 타입을 선언한 클래스 혹은 그 패키지에서만 유용한 기능은 private이나 package-private 메서드로 구현한다. <br>
  이렇게 구현된 열거 타입 상수는 자신을 선언한 클래스 혹은 패키지에서만
  사용할 수 있는 기능을 담게 된다. <br>
- 널리 쓰이는 열거 타입은 톱레벨 클래스로 만들고, 특정 톱레벨 클래스에서만 쓰인다면 해당 클래스의 멤버 클래스로 만든다. <br>

<br>

### 상수별 메서드 구현

상수마다 동작이 달라져야 하는 상황이 있을 때, switch문보다는 상수별 메서드 구현을 사용하자. <br>
상수별 메서드 구현은 열거 타입에 apply라는 추상 메서드를 선언하고 각 상수별 클래스 몸체, 즉 각 상수에서 자신에 맞게 재정의하는 방법이다. <br>

상수별 메서드 구현에는 열거 타입 상수끼리 코드를 공유하기 어렵다는 단점이 있다. <br>

이 때, 제일 깔끔한 방법은 전략 열거 타입 패턴을 사용하는 것이다. <br>
이 패턴은 switch문보다 복잡하지만 더 안전하고 유연하다. <br>
switch문은 열거 타입의 상수별 동작을 구현하는데 적합하지 않지만, **기존 열거 타입에 상수별 동작을 혼합해 넣을 때는 switch문이 좋은 선택이 될 수 있다.** <br>

**필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자.** <br>
**열거 타입에 정의된 상수 개수가 영원히 고정 불변일 필요는 없다.** <br>

<br><br>



## 아이템35. Ordinal 메서드 대신 인스턴스 필드를 사용하라

대부분의 열거 타입 상수는 자연스럽게 하나의 정숫값에 대응된다. <br>
그리고 모든 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal이라는 메서드를 제공한다. <br>

<br>

### ordinal을 잘못 사용했을 때

- 동작은 하지만 유지보수하기가 끔찍하다. <br>
- 값을 중간에 비워둘 수 없다. <br>

<br>

### 해결책

**열거 타입 상수에 연결된 값은 ordinal 메서드로 얻지 말고, 인스턴스 필드에 저장하자.**<br>

ordinal은 EnumSet과 EnumMap 같이 열거 타입 기반의 범용 자료구조에 쓸 목적으로 설계되었기 때문에, 이런 용도가 아니라면 절대 사용하지 말아야 한다.<br> 


<br><br>


## 아이템36. 비트 필드 대신 EnumSet을 사용하라

열거한 값들이 주로 집합으로 사용될 경우, 예전에는 각 상수에 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴을 사용해왔다. <br>

<br>

### 비트 필드 열거 상수

- 비트별 OR을 사용해 여러 상수를 하나의 집합으로 모을 수 있으며, 이렇게 만들어진 집합을 비트 필드라고 한다. <br>
- 비트 필드를 사용하면 비트별 연산을 사용해 합집합과 교집합 같은 집합 연산을 효율적으로 수행할 수 있다. <br>
- 하지만 정수 열거 상수의 단점을 그대로 지니며, 추가로 문제를 안고 있다. <br>

<br>

### EnumSet 

Java.util 패키지의 EnumSet 클래스는 열거 타입 상수의 값으로 구성된 집합을 효과적으로 표현해준다. <br>
Set 인터페이스를 완벽히 구현하며, 타입 안전하고, 다른 어떤 Set 구현체와도 함께 사용할 수 있다. EnumSet의 내부는 비트 벡터로 구현되었지만 난해한 작업을 EnumSet이 다 처리해주기 때문에 비트를 직접 다룰 때 흔히 겪는 오류들에서 해방된다. <br>


<br><br>


## 아이템37. Ordinal 인덱싱 대신 EnumMap을 사용하라

배열이나 리스트에서 원소를 꺼낼 때 ordinal 메서드로 인덱스를 얻는 코드가 있다. <br>
이 코드는 문제가 많다. <br>

<br>

### 문제점

- 배열은 제네릭과 호환되지 않으니 비검사 형변환을 수행해야 하고 깔끔히 컴파일되지 않을 것이다. <br>
- 배열은 각 인덱스의 의미를 모르니 출력 결과에 직접 레이블을 달아야 한다. <br>
- 정확한 정숫값을 사용한다는 것을 직접 보증해야 한다. <br>
  정수는 열거 타입과 달리 타입 안전하지 않기 때문이다. <br>

<br>

### 해결책

열거 타입을 키로 사용하도록 설계한 아주 빠른 Map 구현체인 EnumMap이 있다. <br>

- 더 짧고 명료하며 성능도 전과 비등하다. <br>
- 안전하지 않은 형변환은 쓰지 않고, 맵의 키인 열거 타입이 그 자체로 출력용 문자열을 제공하니 출력 결과에 직접 레이블을 달 일도 없다. <br>
- 배열 인덱스를 계산하는 과정에서 오류 가능성도 원천봉쇄된다. <br>
- 스트림을 사용해 맵을 관리하면 코드를 더 줄일 수 있다. <br>


<br><br>


## 아이템38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라

열거 타입은 거의 모든 상황에서 타입 안전 열거 패턴보다 우수하다. <br>

단, 예외가 하나 있으니, 타입 안전 열거 패턴은 확장할 수 있으니 열거 타입은 그럴 수 없다. <br>
대부분 상황에서 열거 타입을 확장하는 것은 좋지 않은 생각이다. <br>

그런데 확장할 수 있는 열거 타입이 어울리는 쓰임이 최소한 하나는 있다. <br>
바로 연산 코드다. 연산 코드의 각 원소는 특정 기계가 수행하는 연산을 뜻한다. <br>
이따금 API가 제공하는 기본 연산 외에 사용자 확장 연산을 추가할 수 있도록 열어줘야 할 때가 있다. <br>

<br>

### 해결책

열거 타입이 임의의 인터페이스를 구현할 수 있다는 사실을 이용하는 것이다. <br>
연산 코드용 인터페이스를 정의하고 열거 타입이 이 인터페이스를 구현하게 하면 된다. <br>
이 때 열거 타입이 그 인터페이스의 표준 구현체 역할을 한다. <br>

기본 열거 타입 대신 확장된 열거 타입을 넘겨 확장된 열거 타입의 원소 모두를 사용하게 할 수도 있다. <br>

인터페이스를 이용해 확장 가능한 열거 타입을 흉내 내는 방식에도 한 가지 사소한 문제가 있다. <br>
바로 열거 타입끼리 구현을 상속할 수 없다는 점이다. <br>
아무 상태에도 의존하지 않는 경우에는 디폴트 구현을 이용해 인터페이스에 추가하는 방법이 있다. <br>

반면 그렇지 않은 경우일 때, 공유하는 기능이 많다면 그 부분을 별도의 도우미 클래스나 정적 도우미 메서드로 분리하는 방식으로 코드 중복을 없앨 수 있을 것이다. <br>



<br><br>

## 아이템39. 명명 패턴보다 애너테이션을 사용하라

전통적으로 도구나 프레임워크가 특별히 다뤄야 할 프로그램 요소에는 딱 구분되는 명명 패턴을 적용해왔다. <br>

<br>

### 단점

- 오타가 나면 안된다. <br>
- 올바른 프로그램 요소에서만 사용되리라 보증할 방법이 없다. <br>
- 프로그램 요소를 매개변수로 전달할 마땅한 방법이 없다. <br>

<br>

애너테이션은 이 모든 문제를 해결해주는 개념이다. <br>

다른 프로그래머가 소스코드에 추가 정보를 제공할 수 있는 도구를 만드는 일을 한다면 적당한 애너테이션 타입도 함께 정의해 제공하자. <br>

**애너테이션으로 할 수 있는 일을 명명 패턴으로 처리할 이유는 없다.** <br>

일반 프로그래머가 애너테이션 타입을 직접 정의할 일은 거의 없지만, **자바 프로그래머라면 예외없이 자바가 제공하는 애너테이션 타입들은 사용해야 한다.** <br>

<br><br>



## 아이템40. @Override 애너테이션을 일관되게 사용하라

자바가 기본으로 제공하는 애너테이션 중 보통의 프로그래머에게 가장 중요한 것은 @Override일 것이다. <br>
@Override는 메서드 선언에만 달 수 있으며, 이 애너테이션이 달렸다는 것은 상위 타입의 메서드를 재정의했음을 뜻한다. <br>

이 애너테이션을 일관되게 사용하면 여러가지 악명 높은 버그들을 예방해준다. <br>

- **상위 클래스의 메서드를 재정의하려는 모든 메서드에 @Override 애너테이션을 달자.** <br>
  예외는 한 가지뿐이다. <br>
  구체클래스에서 상위클래스의 추상메서드를 재정의할 때는 굳이 @Override를 달지 않아도 된다.  컴파일러가 바로 알려주기 때문이다. <br>
- IDE는 @Override를 일관되게 사용하도록 부추기기도 한다. <br>
- @Override는 클래스뿐 아니라 인터페이스의 메서드를 재정의할 때도 사용할 수 있다. <br>
- 하지만 추상 클래스나 인터페이스에서는 상위 클래스나 상위 인터페이스의 메서드를 재정의하는 모든 메서드에 @Override를 다는 것이 좋다.<br>


<br><br>


## 아이템41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스를 마커 인터페이스라 한다. <br>

마커 애너테이션이 등장하면서 마커 인터페이스는 구식이 되었다는 이야기가 있는데, 사실이 아니다. <br>

<br>

### 마커 인터페이스가 마커 애너테이션보다 나은 점 

- **마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸 수 있으나, 마커 애너테이션은 그렇지 않다.** <br>
  마커 인터페이스는 어엿한 타입이기 때문에, 마커 애너테이션을 사용했다면 런타임에야 발견될 오류를 컴파일타임에 잡을 수 있다. <br>
- **적용 대상을 더 정밀하게 지정할 수 있다.** <br>
  적용 대산을 ElementType.TYPE으로 선언한 애너테이션은 모든 타입(클래스, 인터페이스, 열거 타입, 애너테이션)에 달 수 있다. 부착할 수 있는 타입을 더 세밀하게 제한하지는 못한다는 뜻이다. <br>

<br>

### 마커 애너테이션이 마커 인터페이스가보다 나은 점

- **거대한 애너테이션 시스템의 지원을 받는다.** <br>
  따라서 애너테이션을 적극 활용하는 프레임워크에서는 마커 애너테이션을 쓰는 쪽이 일관성을 지키는데 유리할 것이다. <br>

